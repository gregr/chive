Copyright 2010 Gregory L. Rosenblatt

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

================================================================
module/environment-annotated symbols rather than gensym for renaming?
../ and ./ relative paths, / absolute path, otherwise use search path
more flexible environment linking
explicit module construction
separable module interfaces from definitions
parametric modules
parser
        default reader as a parser with configurable read-table
        reader macros: importing/exporting them

make-foo a b c =
         module
                compound-interface
                        export (x y) (macros and types) (ops and readtable-strings)
                        export (z)
                namespace
                        import (a b c)
                        open [core std]
                        inline
                                d e f = ...
                                g = ...
                        files ["blah" "bleh"]
                        text "j k = ..."

constancy vs. mutability
thunk/strict-typing

security implications of ctx argument to macros?
null ctx for fully expanded syntax?
limited expand privileges?
import-safe/unsafe
auditing for global communication channels
safety of exceptions or conditions/restarts
resource limits
thread state

protection of macro inputs and outputs
forms given to macros that don't name identifiers, but are identifier objects that can optionally be converted to names? (unforgeable identifiers, no direct access to caller's context)
sealed macro expansions that cannot be embedded in forms without being unsealed

privileged scope (master of the machine) contains operators to inspect/debug/modify/execute anything subordinate to it
implies virtual machine hierarchies: machines that simulate machines that simulate machines...
parent machines do not need to trust child machines

don't truncate handler stack upon finding a handler
      -unwound handlers pop themselves
derive throw and build on that
restart lists need to be segmented by interleaved handler pushes

notion of tags separate from types/constructors (and used for dispatch)
capabilities/effects
encapsulation of namespace contexts
  -separation of the invoking context vs. invoked
nicer list syntax using reader macros
rename primitives without using leading-#
conditions: signals/restarts
type-error hook
weak ref
gc-stable ref (related?: distributed refs)
module-determined constancy/visibility typing
explicit full mutability typing
getTag primitive for explicit dynamic dispatch
smarter thunk-creation
fix future bugs due to lack of Context.withThread where required
expansion history (fix) and attributes for definitions
debugging (improve)
optional automatic downcasting with warnings
option for direct file-inclusion
interpreter-agnostic expression evaluation
import path [modname] [[only (...)]|[hide (...)]] [rename (...)]]
thread interaction with delays, module-loading, etc.
AST pretty-printing
arrays
strings
structs/tuples
records/row-typing
dependency analysis
           -driving the eval order of non-sequenced exprs/typedefs
           -searching mutually-recursive modules for missing dependencies

OOP:
  -constructors build a new record containing method closures and data attrs
  -constructor-impls take any record containing the required slots
    -inheritance:
      -new constructor applies old constructor-impl to new record type
        -allows more efficient polymorphic delegation than a layered approach
        -mixins seem easy enough
        -takes advantage of row-typing for records
        -extensibility?
  -orthogonal dynamic properties?
  -prototypes?
reflection:
  -show field names
  -show field names with short or full value descriptions

================================================================
= disorganized ideas
================================================================
ffi?:
networking
filesystem/stdio/os
threads/processes/signals?

deferred compiler/interpreter (eval instead of compile for pure interpreters):
given a list of inputs assumed present at compile-time;
  causes some input ops to become pure
  default list includes module paths (explicit exclusion allows late-loading)
eval definitions, compute dependencies
postpone eval of pure value exprs until demanded, but compute dependencies
compile effectful exprs (after demanding their dependencies)
eval pure values when expansion requires it
no need to compile unneeded definitions/pure exprs
if expansion relies on runtime input, compile the continued expansion/eval;
  you end up having to compile interpreter/jit compiler into the executable
Root db usage (multimethods, record fields of tags, etc.) in exprs implies dynamic switch (can be inlined during proc specialization; can be made into static switch using type information)
