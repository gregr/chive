# Copyright 2010 Gregory L. Rosenblatt

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set attr.subs to nil by default
parser

disorganized ideas:

{Macro proc}
{Proc ...} # hidden?

{Root tags modules multimethod-tables?...}
{Module path dependencies dependants exports senv env}
{Context kernel module senv env} # and use unpacking for accessors
#parser hooks? meta-circular debugging and expansion history? tracer hooks?

# how are modules loaded?

env-new env
env-add env sym val
env-get env sym conseq altern?

var
unboxed
newtag
construct
unpack/pack
gettag
seq
proc
# simply group adjacent applications? primitives curried by default too
#call # only on known procs?
#apply # what data does it take?
# explicit apply could be useful as an assertion about the number of arguments
switch discriminant defaultCont [(tag|[unboxed val])* cont]*
throw
catch

expand form senv env
eval form senv env

{Unit}
{Nil}
{Cons head tail}
{Symbol symdesc}
{SynClo senv frees form}

Int
Float
Char
String

Array? # hidden?
array-new
array-length
array-unpack/pack

gensym
alias

update
 delay
 force

ffi?:
networking
filesystem/stdio/os
threads/processes/signals?

deferred compiler/interpreter (eval instead of compile for pure interpreters):
given a list of inputs assumed present at compile-time;
  causes some input ops to become pure
  default list includes module paths (explicit exclusion allows late-loading)
eval definitions, compute dependencies
postpone eval of pure value exprs until demanded, but compute dependencies
compile effectful exprs (after demanding their dependencies)
eval pure values when expansion requires it
no need to compile unneeded definitions/pure exprs
if expansion relies on runtime input, compile the continued expansion/eval;
  you end up having to compile interpreter/jit compiler into the executable
Kernel db usage (multimethods, record fields of tags, etc.) in exprs implies dynamic switch (can be inlined during proc specialization; can be made into static switch using type information)
