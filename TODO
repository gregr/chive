Copyright 2010 Gregory L. Rosenblatt

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

================================================================
fix deftypes
option for direct file-inclusion
interpreter-agnostic expression evaluation
import path [modname] [[only (...)]|[hide (...)]] [rename (...)]]
thread interaction with delays, module-loading, etc.
expansion history (fix) and attributes for definitions
exprs: change expand to a proc; eliminate eval; add letrec
dynamic dispatch
AST pretty-printing
structs/tuples
records/row-typing
reader macros/importing them
dependency analysis
           -driving the eval order of non-sequenced exprs/typedefs
           -searching mutually-recursive modules for missing dependencies

================================================================
= disorganized ideas
================================================================
(#proc (xs ys) ((#proc (a b) (xs)) (#node-pack \: 1 xs (\: ys (\: ys xs))) (#node-pack \: 1 ys xs))) (\: 1 Nil) (\: 5 Nil)

{Root tags modules multimethod-tables?...}
{Module path dependencies dependants exports op-env senv env}
#parser hooks? meta-circular debugging and expansion history? tracer hooks?

# how are modules loaded?

binding and aliasing

array-new
array-length
array-unpack/pack

gensym

ffi?:
networking
filesystem/stdio/os
threads/processes/signals?

deferred compiler/interpreter (eval instead of compile for pure interpreters):
given a list of inputs assumed present at compile-time;
  causes some input ops to become pure
  default list includes module paths (explicit exclusion allows late-loading)
eval definitions, compute dependencies
postpone eval of pure value exprs until demanded, but compute dependencies
compile effectful exprs (after demanding their dependencies)
eval pure values when expansion requires it
no need to compile unneeded definitions/pure exprs
if expansion relies on runtime input, compile the continued expansion/eval;
  you end up having to compile interpreter/jit compiler into the executable
Root db usage (multimethods, record fields of tags, etc.) in exprs implies dynamic switch (can be inlined during proc specialization; can be made into static switch using type information)
