## Copyright 2010 Gregory L. Rosenblatt

## Licensed under the Apache License, Version 2.0 (the "License");
## you may not use this file except in compliance with the License.
## You may obtain a copy of the License at

##     http://www.apache.org/licenses/LICENSE-2.0

## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS,
## WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
## See the License for the specific language governing permissions and
## limitations under the License.

#def-op (:) infix right 5
#def hd (#proc (xs) (#node-unpack (:) 0 xs))
#def tl (#proc (xs) (#node-unpack (:) 1 xs))
#def synclo-form (#proc (sc) (#node-unpack SynClo 2 sc))
#def testSwitch
  #switch (1:2:Nil)
    (((Nil) 3) ((\:) 4))
#def #quote-sym (Macro (#proc (ctx form)
  ((SynClo (#ctx) Nil (Symbol (#unbox Symbol))):
   ((SynClo (#ctx) Nil (Symbol (#unbox #unbox))):(hd (tl form)):Nil):Nil)))
#def #quote
  #proc (xs)
    #switch xs
      ((() xs)
       ((Symbol) ((SynClo (#ctx) Nil (#quote-sym #quote-sym)):xs:Nil))
       ((Nil) (SynClo (#ctx) Nil (#quote-sym Nil)))
       ((\:) ((SynClo (#ctx) Nil (#quote-sym \:)):
              (#quote (hd xs)):(#quote (tl xs)):Nil))
       ((SynClo) (#quote (synclo-form xs))))
#def quote (Macro (#proc (ctx form) (#quote (hd (tl form)))))
#def squote (Macro (#proc (ctx form)
  ((SynClo (#ctx) Nil (quote SynClo)):(SynClo (#ctx) Nil (quote (#ctx))):
   (SynClo (#ctx) Nil (quote Nil)):
   ((SynClo (#ctx) Nil (quote quote)):(hd (tl form)):Nil):Nil)))
#def #def-macro (Macro (#proc (ctx form)
  ((squote #def):(hd (tl form)):
   ((squote Macro):((squote #proc):(tl (tl form))):Nil):Nil)))
#def-macro #def-proc (ctx form)
  ((squote #def):(hd (tl form)):((squote #proc):(tl (tl form))):Nil)
#def-proc id (x) x
#def-proc rev-append (xs ys)
  #switch ys
    (((Nil) xs)
     ((\:) (rev-append (hd ys:xs) (tl ys))))
#def-proc reverse (xs) (rev-append Nil xs)
#def-proc map (f xs)
  #switch xs
    (((Nil) Nil)
     ((\:) (f (hd xs):map f (tl xs))))
#def-proc strip-synclo (frm)
  #switch frm (((SynClo) (synclo-form frm)) (() frm))
#def-proc strip-synclos (frm)
  #switch frm (((\:) (map strip-synclos frm))
               ((SynClo) (strip-synclos (strip-synclo frm)))
               (() frm))
#def-proc #ns-env (ns) (hd (#ctx-env (#ns-ctx ns)))
#def-macro #globals (ctx form)
  ((squote #ns-env):((squote #ctx-ns):(quote (#ctx)):Nil):Nil)
#def-macro #locals (ctx form) ((squote #ctx-env):(quote (#ctx)):Nil)
#def-types
  Bool (#Variant True False)
  True (#Product)
  False (#Product)
#def-proc ttl (xs) (tl (tl xs))
#def-proc tttl (xs) (tl (ttl xs))
#def-proc htl (xs) (hd (tl xs))
#def-proc httl (xs) (hd (ttl xs))
#def-proc htttl (xs) (hd (tttl xs))
#def-macro #if (ctx form)
  #let () ((cnd (htl form)) (cnsq (httl form)) (altrn (htttl form))) ()
    ((squote #switch):cnd:
     ((squote (True):cnsq:Nil):(squote (False):altrn:Nil):Nil):Nil)
#def-proc gensym (_) (#alias (quote \#gsym))
#def-types (Ref (#Product Any))
#def-proc ref-get (ref) (#node-unpack Ref 0 ref)
#def-proc ref-set (ref val) (#node-pack Ref 0 ref val)

#def-macro #def-tl-data (ctx form)
  #let () ((name (htl form)) (body (httl form))
           (key (((squote quote):gensym ():Nil)))) ()
    ((squote #seq):((squote #def):name:key:Nil):
     ((squote #init-tl-data):key:body:Nil):Nil)

#def-proc default-cond-handler (cnd continue unravel) (unravel ())

#def-tl-data cond-handler-state (Ref (default-cond-handler:Nil))
#def-proc get-cond-handler-state (_) (#get-tl-data cond-handler-state)
#def-proc get-cond-handlers (_) (ref-get (#get-tl-data cond-handler-state))
#def-proc push-cond-handler (c-h)
  #let () ((ref (get-cond-handler-state ()))) ()
    ref-set ref (c-h:ref-get ref)
#def-proc pop-cond-handler (_)
  #let () ((ref (get-cond-handler-state ()))) ()
    ref-set ref (tl (ref-get ref))
#def-proc set-cond-handlers (hs) (ref-set (get-cond-handler-state ()) hs)

#def-tl-data restart-state (Ref Nil)
#def-proc get-restarts (_) (#get-tl-data restart-state)
#def-proc push-restarts (restarts)
  #let () ((ref (get-restarts ()))) ()
    ref-set ref (restarts:(ref-get ref))
#def-proc pop-restarts (_)
  #let () ((ref (get-restarts ()))) ()
    ref-set ref (tl (ref-get ref))

#def-proc apply-cond-handler (cnd hs)
  #let () ((handler (hd hs)) (rest (tl hs)))
    ((continue (#proc (_) (apply-cond-handler cnd rest)))
     (unravel (#proc (_) (#seq (set-cond-handlers hs) (#unwind)))))
    handler cnd continue unravel
#def-proc signal (cnd) (apply-cond-handler cnd (get-cond-handlers ()))

#def-macro bind-cond-handler (ctx form)
  #let () ((body (htl form)) (handler (httl form)) (altern (htttl form))
           (pop ((squote pop-cond-handler):Nil:Nil)) (val (gensym ()))) ()
    ((squote #seq):((squote push-cond-handler):handler:Nil):
     ((squote #catch-unwind):
      ((squote #let):Nil:((val:body:Nil):Nil):Nil:
       ((squote #seq):pop:val:Nil):Nil):
      ((squote #seq):pop:altern:Nil):Nil):Nil)

#def tc-result (Ref ())
#def-proc test-cond (xs ys)
  bind-cond-handler
    bind-cond-handler
      signal 42
      (#proc (cnd continue unravel) (continue ()))
      (#unwind)
    (#proc (cnd continue unravel)
      (#seq (ref-set tc-result (quote alt0)) (unravel ())))
    37
